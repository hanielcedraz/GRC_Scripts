#!/usr/bin/env Rscript

suppressPackageStartupMessages(library("optparse"))
# specify our desired options in a list
# by default OptionParser will add an help option equivalent to
# make_option(c("-h", "--help"), action="store_true", default=FALSE,
# help="Show this help message and exit")
option_list <- list(
  make_option(c("-f", "--file"), type="character", default="samples.txt",
              help="The filename of the sample file, default is samples.txt",
              dest="samplesFile", metavar="sample file"),
  make_option(c("-d", "--directory"), type="character", default="00-RawData",
              help="Directory where the raw sequence data is stored, default is 00-RawData",
              dest="Raw_Folder", metavar="raw folder"),
  make_option(c("-q", "--quality"), type="integer", default=24,
              help="Quality score to use during lucy trimming, default is 24",
              dest="qual", metavar="quality"),
  make_option(c("-m", "--miniumumLength"), type="integer", default=150,
              help="Discard reads less then minimum length, default is 150",
              dest="minL", metavar="min length"),
  make_option(c("-o", "--overlap"), type="integer", default=275,
              help="Overlap parameter for flash, default is 275",
              dest="overlap", metavar="overlap"),
  make_option(c("-p", "--processors"), type="integer", default=1,
              help="number of processors to use, default is 1",
              dest="procs", metavar="processors")
)
# get command line options, if help option encountered print help and exit,
# otherwise if options not found on command line then set defaults,
opt <- parse_args(OptionParser(option_list=option_list))

suppressPackageStartupMessages(library("ShortRead"))
suppressPackageStartupMessages(library("parallel"))
####################################################
### FUNCTIONS
####################################################
first_dedup <- function(r,o,d){
  paste("screen_duplicates_PE.py","-d", r, "-o", o, ">>", file.path(d,"preprocessing_output.txt"), sep=" ")
}

second_seqy <- function(r1,r2,o,minL=150, q=24,d) {
	paste("seqyclean -qual", q, q, "-c /mnt/home/uirig/user_data/genomes/phage-phiX174.fa -minimum_read_length",minL,"--new2old_illumina -1",r1,"-2",r2,"-o",o, ">>", file.path(d,"preprocessing_output.txt"),sep=" ")
}

third_flash <- function(r1,r2,o,overlap=275,d){
	paste("flash --max-overlap=",overlap," --output-prefix=",o," ",r1," ",r2, ">>", file.path(d,"preprocessing_output.txt"),sep="")
}

fourth_link <- function(se1,se2,r1,r2,o){
  require("ShortRead")
  ## first merge the 2 SE files
  se <- file.path(dirname(se1),"merged_SE_files.fastq")
  if (!file.exists(se)){
    fq <- readFastq(c(se1,se2))
    writeFastq(fq,se)
	}
  paste("ln -sf",file.path("../..",se),paste(o,"merged_SE.fastq",sep="_"),";ln -sf",file.path("../..",r1),paste(o,"notcombined_PE1.fastq",sep="_"),";ln -sf",file.path("../..",r2),paste(o,"notcombined_PE2.fastq",sep="_"),";",sep=" ")
}

final_report_fun <- function(f,o){
  paste("fastq_info.py", "-d",f,">>",file.path(o,"preprocessing_output.txt"))
}

report_fun <- function(d,f){
  output <- readLines(file.path(d,"preprocessing_output.txt"))
  dedup_res <- output[substring(output,1,6) == "Final:"]
  dedup_res <- rev(dedup_res)[1]
  seqyclean_res <- output[(rev(which(output == "----------------------Summary for PE & SE----------------------"))[1]+1):(rev(which(output == "====================Done cleaning===================="))[1]-1)]
  flash_res <- output[(which(output=="[FLASH] Read combination statistics:")+1):(which(output=="[FLASH] Read combination statistics:")+4)]

  dedup_data <- as.numeric(strsplit(dedup_res,split=" \\| | ")[[1]][seq(3,13,by=2)])
#  dedup_data <- as.numeric(strsplit(dedup_res,split=" \\| | ")[[1]][seq(2,12,by=2)])
#  names(dedup_data) <- c("Reads","Duplicates","Forward","Reverse","Percent","Reads_Sec")

  seqyclean_data <- strsplit(seqyclean_res,split=" |%, |, |%")
  seqyclean_data <- as.numeric( c(seqyclean_data[[1]][c(3,4,6,7)],seqyclean_data[[2]][c(3,4,6,7)],seqyclean_data[[3]][c(5,7)],seqyclean_data[[4]][c(5,7)],seqyclean_data[[5]][5],seqyclean_data[[6]][5]))
#  names(seqyclean_data) <- c("Pairs_Kept","Kept_Percentage","Kept_Bases","Discarded_Kept","Discarded_Percentage","Discarded_Bases","PE1_single_reads","PE1_single_bases","PE2_single_reads","PE2_single_bases","PE1_length","PE2_length")

  flash_data <- as.numeric(sapply(strsplit(flash_res,split=" +|%"),"[[",4L))
#  names(flash_data) <- c("Paired_Reads","Reads_Combined","Reads_Uncombined","Combined_Percentage")

  final_info <- read.table(file.path(f,"read_data.txt"),sep="\t")
  final_data <- final_info[,2]
  return(c(dedup_data,seqyclean_data,flash_data,tail(final_data,2)))
}


r454_seqy <- function(sff,o,minL=225,q=24,d){
	paste("seqyclean -qual",q,q,"-minimum_read_length",minL,"-454",sff,"-o",o, ">>", file.path(d,"preprocessing_output.txt"),sep=" ")
}
r454_link <- function(sff,o){
	paste("ln -sf",sff,paste(o,"sff",sep="."),sep=" ")
}

process_sample <- function(folder,sample,Raw_Folder,Clean_Folder,Final_Folder,qual,minL,overlap){
    write(paste(sample,":Processing folder ",folder,sep=""),stdout())
    if(file.info(file.path(Raw_Folder,folder))$isdir){ ## ILLUMINA FOLDER, EXPECT PAIRED READS
    
    if(file.exists(file.path(Clean_Folder, sample))) unlink(file.path(Clean_Folder, sample),recursive=TRUE)
    dir.create(file.path(Clean_Folder, sample),recursive=TRUE,showWarnings=FALSE)
    
    output <- file.path(Clean_Folder,sample,paste(sample,sep="_"))
    write(paste(sample,":\tde-duplicating reads",sep=""),stdout())
    system(first_dedup(file.path(Raw_Folder,folder),output,file.path(Clean_Folder,sample)))

    ## second use seqyclean to remove contaminant, adapters and trim for quality
    Read1 <- paste(output,"nodup_PE1.fastq.gz",sep="_")
    Read2 <- paste(output,"nodup_PE2.fastq.gz",sep="_")
    output <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,sep=""),sep="_"))
    write(paste(sample,":\trunning seqyclean",sep=""),stdout())
    system(second_seqy(Read1, Read2, output, minL=minL, q=qual, file.path(Clean_Folder,sample)))

    ## third use flash to join overlapping paired-end reads
    Read1 <- paste(output,"_PE1.fastq",sep="")
    Read2 <- paste(output,"_PE2.fastq",sep="")
    output <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,sep=""),sep="_"))
    write(paste(sample,":\tjoining reads",sep=""),stdout())
    system(third_flash(Read1, Read2,output,overlap=overlap,file.path(Clean_Folder,sample)))

    ## link the final files to another folder
    SE1 <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,sep=""),"SE.fastq",sep="_"))
    SE2 <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,".extendedFrags.fastq",sep=""),sep="_"))

    Read1 <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,sep=""),".notCombined_1.fastq",sep="_"))
    Read2 <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,sep=""),".notCombined_2.fastq",sep="_"))
    output <- file.path(getwd(),Final_Folder,sample,sample)
    
    if(file.exists(file.path(Final_Folder,sample))) unlink(file.path(Final_Folder,sample),recursive=TRUE)
    dir.create(file.path(Final_Folder,sample),recursive=TRUE,showWarnings=FALSE)
    write(paste(sample,":\tcreating links to final files in ",file.path(Final_Folder,sample),sep=""),stdout())
    system(fourth_link(SE1,SE2,Read1,Read2,output))

    write(paste(sample,":\tcreating report of final files in ",file.path(Final_Folder,sample),sep=""),stdout())
    system(final_report_fun(file.path(Final_Folder,sample),file.path(Clean_Folder,sample)))

    ## end preprocessing
  } else { ## 454 READS
    SFF <- file.path(Raw_Folder,folder)
    folder <- sub(".sff","",folder)
    output <- file.path(getwd(),Clean_Folder,sample,paste(sample,paste("q",qual,"min",minL,sep=""),sep="_"))
    system(r454_seqy(SFF,output,minL=250,q=20,file.path(getwd(),Clean_Folder,sample)))
    SFF <- paste(output,"sff",sep=".")
    output <- file.path(getwd(),Final_Folder,sample,sample)
    dir.create(file.path(Final_Folder,sample),recursive=TRUE,showWarnings=FALSE)
    system(r454_link(SFF,output))
  }	
}
##########################################

##########################################
## SETUP PROCESSING
## test
# opt <- list(samplesFile="samples.txt",Raw_Folder="00-RawData",qual=24,minL=150,overlap=275,procs=1)

if ( !file.exists(opt$samplesFile) ) {
  write(paste("Sample file",opt$samplesFile,"does not exist\n"), stderr())
  stop()
}

### opt$samplesFile$SEQUENCE_ID should be the folder name inside of Raw_Folder
### opt$samplesFile$SAMPLE_ID should be the sample name
targets <- read.table(opt$samplesFile,sep="",header=T,as.is=T)

if (detectCores() < opt$procs){
  write(paste("number of cores specified (",opt$procs,") is greater than the number of cores available (",detectCores(),")",sep=" "),stdout())
  stop()
}

##########################################
## directory structure
## assumes Illumina data is under a folder, named opt$samplesFile$SEQUENCE_ID and 454 sff files are just files in the folder
Raw_Folder <- opt$Raw_Folder
## where preprocessing clean results are saved
Clean_Folder <- "01-Clean_Merge"
## final preprocess file are linked (from Clean_Folder) to this folder
Final_Folder <- "02-Cleaned"

if (any(is.na(match(targets$SEQUENCE_ID,dir(path=Raw_Folder))))){
  write("samples file does not match the raw data folder structure\nExpecting two columns (tab delimited) with column headings SEQUENCE_ID and SAMPLE_ID", stderr())
  stop()
}

##########################################
### main function

write(paste("samples sheet contains", nrow(targets), "samples to process",sep=" "),stdout())


mclapply(seq.int(1,nrow(targets)), function(index){
  folder <- targets$SEQUENCE_ID[index]
  sample <- targets$SAMPLE_ID[index]
  try({process_sample(folder,sample,Raw_Folder,Clean_Folder,Final_Folder,opt$qual,opt$minL,opt$overlap)})
},mc.cores=opt$procs)


##########################################
### Generate Read Report
write(paste("Generating Final Preprocessing Report for all samples",sep=" "),stdout())

report <- matrix(NA,ncol=26,nrow=length(targets$SEQUENCE_ID))
for (index in seq_along(targets$SAMPLE_ID)){
  folder <- targets$SEQUENCE_ID[index]
  sample <- targets$SAMPLE_ID[index]
  try({report[index,] <- report_fun(file.path(Clean_Folder,sample),file.path(Final_Folder,sample))})
}
report <- as.data.frame(report)

colnames(report) <- c("Reads","Duplicates","Forward","Reverse","Percent","Reads_Sec","Pairs_Kept","Kept_Percentage","Kept_Bases","Kept_Bases_Percentage","Discarded_Kept","Discarded_Percentage","Discarded_Bases","Discarded_Bases_Percentage","PE1_single_reads","PE1_single_bases","PE2_single_reads","PE2_single_bases","PE1_length","PE2_length","Paired_Reads","Reads_Combined","Reads_Uncombined","Combined_Percentage","Total_nReads","Total_nBases")
rownames(report) <- targets$SAMPLE_ID
write.table(report,file="preproc_experiment_report.txt",sep="\t",row.names=TRUE,col.names=TRUE,quote=F)

write("Finished processing samples",stdout())

