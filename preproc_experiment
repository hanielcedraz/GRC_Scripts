#!/usr/bin/env Rscript


suppressPackageStartupMessages(library("optparse"))
# specify our desired options in a list
# by default OptionParser will add an help option equivalent to
# make_option(c("-h", "--help"), action="store_true", default=FALSE,
# help="Show this help message and exit")
option_list <- list(
  make_option(c("-f", "--file"), type="character", default="samples.txt",
              help="The filename of the sample file [default %default]",
              dest="samplesFile", metavar="sample file"),
  make_option(c("-d", "--directory"), type="character", default="00-RawData",
              help="Directory where the raw sequence data is stored [default %default]",
              dest="Raw_Folder", metavar="raw folder"),
  make_option(c("-q", "--quality"), type="integer", default=24,
              help="Quality score to use during lucy trimming [default %default]",
              dest="qual", metavar="quality"),
  make_option(c("-m", "--miniumumLength"), type="integer", default=150,
              help="Discard reads less then minimum length [default %default]",
              dest="minL", metavar="min length"),
  make_option(c("-o", "--overlap"), type="integer", default=275,
              help="Overlap parameter for flash [default %default]",
              dest="overlap", metavar="overlap"),
  make_option(c("-p", "--processors"), type="integer", default=1,
              help="number of processors to use [default %default]",
              dest="procs", metavar="processors"),
  make_option(c("-s", "--skip-duduplicates"), action="store_false", default=FALSE,
              help="do not perform the deduplication step [default %default]",
              dest="skip_dedup", metavar="skip")
)
# get command line options, if help option encountered print help and exit,
# otherwise if options not found on command line then set defaults,
opt <- parse_args(OptionParser(option_list=option_list))

suppressPackageStartupMessages(library("ShortRead"))
suppressPackageStartupMessages(library("parallel"))
####################################################
### FUNCTIONS
####################################################
first_dedup <- function(r,o,d){
  paste("screen_duplicates_PE.py","-d", r, "-o", o, ">>", file.path(d,"preprocessing_output.txt"), sep=" ")
}

second_seqy <- function(r1,r2,o,minL=150, q=24,d) {
	paste("seqyclean -qual", q, q, "-c /mnt/home/uirig/user_data/genomes/phage-phiX174.fa -minimum_read_length",minL,"--new2old_illumina -1",r1,"-2",r2,"-o",o, ">>", file.path(d,"preprocessing_output.txt"),sep=" ")
}

third_flash <- function(r1,r2,o,overlap=275,d){
	paste("flash --max-overlap=",overlap," --output-prefix=",o," ",r1," ",r2, ">>", file.path(d,"preprocessing_output.txt"),sep="")
}

fourth_link <- function(se1,se2,r1,r2,o){
  require("ShortRead")
  ## first merge the 2 SE files
  se <- file.path(dirname(se1),"merged_SE_files.fastq")
  if (!file.exists(se)){
    fq <- readFastq(c(se1,se2))
    writeFastq(fq,se)
	}
  paste("ln -sf",file.path("../..",se),paste(o,"merged_SE.fastq",sep="_"),";ln -sf",file.path("../..",r1),paste(o,"notcombined_PE1.fastq",sep="_"),";ln -sf",file.path("../..",r2),paste(o,"notcombined_PE2.fastq",sep="_"),";",sep=" ")
}


r454_seqy <- function(sff,o,minL=225,q=24,d){
	paste("seqyclean -qual",q,q,"-minimum_read_length",minL,"-454",sff,"-o",o, ">>", file.path(d,"preprocessing_output_454.txt"),sep=" ")
}
r454_link <- function(sff,o){
	paste("ln -sf",sff,paste(o,"sff",sep="."),sep=" ")
}

final_report_fun <- function(f,o){
  paste("fastq_info.py", "-d",f,">>",file.path(o,"preprocessing_output.txt"))
}

process_sample <- function(folder,sample,Raw_Folder,Clean_Folder,Final_Folder,qual,minL,overlap){
    write(paste(sample,":Processing folder ",folder,sep=""),stdout())
    if(file.info(file.path(Raw_Folder,folder))$isdir){ ## ILLUMINA FOLDER, EXPECT PAIRED READS
    
    if(file.exists(file.path(Clean_Folder, sample))) unlink(file.path(Clean_Folder, sample),recursive=TRUE)
    dir.create(file.path(Clean_Folder, sample),recursive=TRUE,showWarnings=FALSE)
    
    output <- file.path(Clean_Folder,sample,paste(sample,sep="_"))
    write(paste(sample,":\tde-duplicating reads",sep=""),stdout())
    system(first_dedup(file.path(Raw_Folder,folder),output,file.path(Clean_Folder,sample)))

    ## second use seqyclean to remove contaminant, adapters and trim for quality
    Read1 <- paste(output,"nodup_PE1.fastq.gz",sep="_")
    Read2 <- paste(output,"nodup_PE2.fastq.gz",sep="_")
    output <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,sep=""),sep="_"))
    write(paste(sample,":\trunning seqyclean",sep=""),stdout())
    system(second_seqy(Read1, Read2, output, minL=minL, q=qual, file.path(Clean_Folder,sample)))

    ## third use flash to join overlapping paired-end reads
    Read1 <- paste(output,"_PE1.fastq",sep="")
    Read2 <- paste(output,"_PE2.fastq",sep="")
    output <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,sep=""),sep="_"))
    write(paste(sample,":\tjoining reads",sep=""),stdout())
    system(third_flash(Read1, Read2,output,overlap=overlap,file.path(Clean_Folder,sample)))

    ## link the final files to another folder
    SE1 <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,sep=""),"SE.fastq",sep="_"))
    SE2 <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,".extendedFrags.fastq",sep=""),sep="_"))

    Read1 <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,".notCombined_1.fastq",sep=""),sep="_"))
    Read2 <- file.path(Clean_Folder,sample,paste(sample,"nodup",paste("q",qual,"min",minL,".notCombined_2.fastq",sep=""),sep="_"))
    output <- file.path(getwd(),Final_Folder,sample,sample)
    
    if(file.exists(file.path(Final_Folder,sample))) unlink(file.path(Final_Folder,sample),recursive=TRUE)
    dir.create(file.path(Final_Folder,sample),recursive=TRUE,showWarnings=FALSE)
    write(paste(sample,":\tcreating links to final files in ",file.path(Final_Folder,sample),sep=""),stdout())
    system(fourth_link(SE1,SE2,Read1,Read2,output))

    write(paste(sample,":\tcreating report of final files in ",file.path(Final_Folder,sample),sep=""),stdout())
    system(final_report_fun(file.path(Final_Folder,sample),file.path(Clean_Folder,sample)))

    ## end preprocessing
  } else { ## 454 READS
    qual454 <- 20
    minL454 <- 250
    SFF <- file.path(Raw_Folder,folder)
    folder <- sub(".sff","",folder)
    output <- file.path(getwd(),Clean_Folder,sample,paste(sample,paste("q",qual454,"min",minL454,sep=""),sep="_"))
    system(r454_seqy(SFF,output,minL=minL454,q=qual454,file.path(getwd(),Clean_Folder,sample)))
    SFF <- paste(output,"sff",sep=".")
    output <- file.path(getwd(),Final_Folder,sample,sample)
    dir.create(file.path(Final_Folder,sample),recursive=TRUE,showWarnings=FALSE)
    system(r454_link(SFF,output))
  }	
}


##########################################

##########################################
## SETUP PROCESSING
## test
# opt <- list(samplesFile="samples.txt",Raw_Folder="00-RawData",qual=24,minL=150,overlap=275,procs=1)

if ( !file.exists(opt$samplesFile) ) {
  write(paste("Sample file",opt$samplesFile,"does not exist\n"), stderr())
  stop()
}

### opt$samplesFile$SEQUENCE_ID should be the folder name inside of Raw_Folder
### opt$samplesFile$SAMPLE_ID should be the sample name
targets <- read.table(opt$samplesFile,sep="",header=T,as.is=T)

if (detectCores() < opt$procs){
  write(paste("number of cores specified (",opt$procs,") is greater than the number of cores available (",detectCores(),")",sep=" "),stdout())
  stop()
}

##########################################
## directory structure
## assumes Illumina data is under a folder, named opt$samplesFile$SEQUENCE_ID and 454 sff files are just files in the folder
Raw_Folder <- opt$Raw_Folder
## where preprocessing clean results are saved
Clean_Folder <- "01-Clean_Merge"
## final preprocess file are linked (from Clean_Folder) to this folder
Final_Folder <- "02-Cleaned"

if (any(is.na(match(targets$SEQUENCE_ID,dir(path=Raw_Folder))))){
  write("samples file does not match the raw data folder structure\nExpecting two columns (tab delimited) with column headings SEQUENCE_ID and SAMPLE_ID", stderr())
  stop()
}

##########################################
### main function

write(paste("samples sheet contains", nrow(targets), "samples to process",sep=" "),stdout())


mclapply(seq.int(1,nrow(targets)), function(index){
  folder <- targets$SEQUENCE_ID[index]
  sample <- targets$SAMPLE_ID[index]
  try({process_sample(folder,sample,Raw_Folder,Clean_Folder,Final_Folder,opt$qual,opt$minL,opt$overlap)})
},mc.cores=opt$procs)


##########################################
### Generate Read Report
write(paste("Generating Final Preprocessing Report for all samples",sep=" "),stdout())

system(paste("preproc_report -f", opt$samplesFile))

write("Finished processing samples",stdout())

